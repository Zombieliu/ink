---
description: >-
  我们就结束了！ 我们的代币合约现在可以在用户之间转移资金，并告诉外界发生这种情况时发生了什么。
  剩下要做的就是介绍approve和transfer_from函数。
---

# 支持批准和转移

### 三次平价转移

本部分的目的是增加其他帐户安全使用某些令牌的功能。

眼前的问题应该是：“我为什么要那个？”

嗯，一种这样的方案是支持分散交换。基本上，其他智能合约可以允许您与其他用户交换令牌，通常是一种令牌交换另一种令牌。但是，这些“出价”并不总是立即执行。也许您想为代币交易获得一笔非常划算的交易，并且会一直坚持到达成交易为止。

好吧，您不必将令牌直接提供给合约（代管），而是可以简单地“批准”它们以代表您花费一些令牌！这意味着在等待交易执行期间，您仍然可以根据需要控制和花费资金。更好的是，您可以批准多个不同的合约或用户来访问您的资金，因此，如果一个合约提供了最佳的交易，则无需从另一个合约中撤出资金并转移它们，这有时会耗费大量时间并且很耗时。

因此，希望您能看到为什么这样的功能会很有用，但是我们如何安全地进行呢？

我们使用两步过程：批准和转移。

### 批准

批准另一个帐户花费您的资金是第三方转帐过程的第一步。 令牌所有者可以指定另一个帐户，以及它可以代表所有者花费的任意数量的令牌。 所有者不必将所有资金都批准由他人使用； 在资金不足的情况下，批准的帐户最多可以从所有者的余额中支出批准的金额。

当一个帐户多次调用批准时，批准的值将简单地覆盖过去批准的任何现有值。 默认情况下，任何两个帐户之间的批准值为0，并且用户始终可以致电批准为0，以撤消从另一个帐户访问其资金的权限。

为了在我们的合约中存储批准，我们需要使用一个稍微花哨的HashMap。

由于每个帐户可以有不同的金额供任何其他帐户使用，因此我们需要使用元组作为我们的键，该键仅指向余额值。 这是看起来的示例：

```text
struct Erc20 {
    /// Balances that are spendable by non-owners: (owner, spender) -> allowed
    allowances: storage::HashMap<(AccountId, AccountId), Balance>,
}
```

在这里，我们定义了表示（所有者，支出者）的元组，以便我们可以使用该元组中的AccountIds查找“支出者”可以从“所有者”余额中支出多少。 请记住，我们将需要再次创建allowance\_of\_or\_zero函数以帮助我们在未初始化帐户时获得其津贴，并需要使用一个名为allowance的getter函数来查找任何一对帐户的当前值。

```text
/// Approve the passed AccountId to spend the specified amount of tokens
/// on the behalf of the message's sender.
#[ink(message)] 
fn approve(&mut self, spender: AccountId, value: Balance) -> bool {/* --snip-- */}
```

调用批准函数时，只需将指定的值插入存储中。 所有者始终是self.env（）。caller（），确保始终对函数调用进行授权。

### 从转移

最后，一旦我们为一个帐户建立了可以在另一个帐户上进行支出的批准，就需要创建一个特殊的transfer\_from函数，该函数使获得批准的用户能够转移这些资金。

如前所述，我们将利用私有的transfer\_from\_to函数来完成大部分传输逻辑。 我们需要介绍的只是授权逻辑。

那么被授权调用此函数意味着什么？

1.self.env（）。caller（）必须具有一定的余量，才能从发件人帐户中支出资金。 

2.津贴不得少于试图转移的价值。 在代码中，可以很容易地表示为：

```text
let allowance = self.allowance_of_or_zero(&from, &self.env().caller());
if allowance < value {
    return false
}
/* --snip-- */
true
```

再次，我们提早退出，如果未通过授权，则返回false。

如果一切看起来都不错，我们只需将更新的配额插入配额HashMap中（让new\_allowance =配额-值），然后在指定的from和to帐户之间调用transfer\_from\_to。

### 小心！

如果您太过注意此功能的逻辑，则可能在智能合约中引入了错误。 请记住，在调用transfer\_from时，self.env（）。caller（）和from帐户用于查找当前配额，但是transfer\_from函数在指定的from和to帐户之间调用。

每当调用transfer\_from时，就会有三个帐户变量在起作用，您需要确保正确使用它们！ 希望我们的测试会发现您犯的任何错误。

### 到你了! 

你快完事！ 这是ERC20代币合同的最后一部分。

按照合约模板中的“操作”完成您的ERC20实施。

请记住要进行 cargo +nightly test 去测试您的工作。

